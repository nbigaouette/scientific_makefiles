#############################################################################
# Generic makefile
# Build using GCC with debug info by default.
# Usage:
#     make [target(s)]
# Possible compilation targets:
#     optimized (Optimized compilation)
#     intel     (Compilation with intel compiler)
#     parallel  (Parallel compilation)
#     prof      (Profiling compilation)
# For GNU Make
# http://www.gnu.org/software/make/manual/make.html
# Nicolas Bigaouette, July 2008
#############################################################################

#############################################################################
# By default, build using GCC (gcc or g++) with debug information
CC				 = gcc
CPP				 = g++
LD				 = $(CC)
build_dir		 = build
CFLAGS			 = -O0 -g -Wall -Wfatal-errors
LDFLAGS			 =
MPILOC			 =
#############################################################################
# Call "make optimized" for optimized compilation
ifneq ($(filter optimized, $(MAKECMDGOALS) ),)
	CFLAGS		:= -O3
endif
#############################################################################
# Call "make prof" for profiling
ifneq ($(filter prof, $(MAKECMDGOALS) ),)
	CFLAGS		+= -pg
	LDFLAGS		+= -pg
endif
#############################################################################
# Call "make cov" for coverage
ifneq ($(filter cov, $(MAKECMDGOALS) ),)
	CFLAGS		+= -fprofile-arcs -ftest-coverage
	LDFLAGS		+= -fprofile-arcs -ftest-coverage
endif
#############################################################################
# Call "make intel" for building using icc (Intel's C compiler)
ifneq ($(filter intel, $(MAKECMDGOALS) ),)
	include Makefile.intel
endif
#############################################################################
# Call "make parallel" for parallel compilation
ifneq ($(filter parallel, $(MAKECMDGOALS) ),)
	CC			:= $(MPILOC)mpicc
	CPP			:= $(MPILOC)mpiCC
	LD			:= $(CC)
	CFLAGS		+= -DPARALLEL
	LDFLAGS		+= -lmpi
endif
#############################################################################

host=$(shell uname -n)
comma:= ,
column:= :
empty:=
space:= $(empty) $(empty)

VPATH			 = $(subst $(space),$(column),$(SRCDIRS) )
# SOURCES			 = $(sort $(subst src/,,$(foreach DIR,$(SRCDIRS) .,$(wildcard $(DIR)/*.$(SRCEXT) ) ) ) )
SOURCES			 = $(subst $(SRCDIRS)/,,$(foreach DIR,$(SRCDIRS) .,$(wildcard $(DIR)/*.$(SRCEXT) ) ) )
NAMES			 = $(subst .$(SRCEXT),,$(SOURCES) )
BASENAMES		 = $(notdir $(NAMES) )
OBJ				 = $(addprefix $(build_dir)/,$(addsuffix .o, $(BASENAMES) ) )

INCLUDES		 = $(addprefix -I./, $(SRCDIRS) )
LDFLAGS			+= -L./$(build_dir)

# Include if necessary
# include Makefile.tinyxml

ifeq ($(host),cerberus)
include Makefile.cerberus
endif

ifeq ($(host),sflogin0)
include Makefile.hpcvl
endif

#############################################################################
# Tools
RM				 = rm -f
CONSOLE			 = konsole --vt_sz 73x41 --noclose -e
# CONSOLE			 = konsole --noclose -e
VALGRIND		 = valgrind
MEMCHECK		 = $(VALGRIND) --tool=memcheck --leak-check=full
CACHEGRIND		 = $(VALGRIND) --tool=callgrind
#############################################################################

a: all
b: all
l: all
all: $(BIN)

o: $(OBJ)

# Linking
$(BIN): $(OBJ)
	$(LD) $(OBJ) -o $(BIN) $(LDFLAGS)

# Compilation of source files, depends on ALL headers
$(build_dir)/%.o : %.$(SRCEXT) $(foreach DIR,$(SRCDIRS) .,$(wildcard $(DIR)/*.$(HEADEXT)))
	$(CC) $(strip $(CFLAGS) $(INCLUDES)) -c $< -o $@


# Clean the project
.PHONY: c clean
c: clean
clean: clean_bin clean_obj clean_doc

# Clean the project of the executable
.PHONY: cb clean_bin
cb: clean_bin
clean_bin:
	$(RM) $(BIN)

# Clean the project of object files
.PHONY: co clean_obj
co: clean_obj
clean_obj:
	$(RM) build/*
# 	find . -iname "*.o" -exec $(RM) {} \;
# 	find . -iname "*.a" -exec $(RM) {} \;
# 	find . -iname "*.so" -exec $(RM) {} \;
# 	find . -iname "*.gcda" -exec $(RM) {} \;
# 	find . -iname "*.gcno" -exec $(RM) {} \;
# 	find . -iname "*.il" -exec $(RM) {} \;

# Clean the project of documentation files
.PHONY: clean_doc
clean_doc:
	rm -fr doc/*

.PHONY: cd clean_dat
cd: clean_dat
clean_dat:
	rm -f *.dat output/*

# Clean the project of everything
.PHONY: d distclean
d: distclean
distclean: clean_bin clean_obj clean_data clean_doc

# Run the program
.PHONY: r run
r: run
run: $(BIN)
	./$(BIN)

# Count the number of lines of project, without tinyxml files
.PHONY: count
count:
	wc -l $(addprefix $(SRCDIRS)/, $(addsuffix .*, $(NAMES) ) )

# Build doxygen documentation
.PHONY: doxygen doc
doc: doxygen
doxygen:
	doxygen

# Run through valgrind for errors
.PHONY: valgrind v
v: valgrind
valgrind:
	$(MEMCHECK) ./$(BIN)
.PHONY: cachegrind cg
cg: cachegrind
cachegrind:
	$(CACHEGRIND) ./$(BIN)

# Run through gdb for debugging
.PHONY: g gdb
g: gdb
gdb: $(BIN)
	gdb --quiet $(BIN)

#############################################################################
# Target depending on the binary. Necessary for the previous
# lines "ifneq ($(filter ..." to work.
intel: $(BIN)
parallel: $(BIN)
optimized: $(BIN)
prof: $(BIN)
cov: $(BIN)

# Force target
force: ;

############ End of file ####################################################
